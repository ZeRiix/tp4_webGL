<!DOCTYPE html>
<html lang="fr">
	<head>
		<title>Couloir Projet WebGL</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="stylesheet" href="css/style.css">
		
	</head>
	<body>

		<div id="text-box">
			<div class="heading">Vers l'infini et l'au-delà !</div>
			<div id="overlay">
				<div id="buttonInit">Initialiser le monde &#x27A1; </div>
			</div>
		  </div>

		  <div id="buttonDoor">
		  <div id="button">
			  Let's open
		  </div>
		  <div id="buttonClose">
			  Let's close
		  </div>
		</div>

		<div id="container">

		</div>
		
	<script src="three.min.js"></script>

	<script>

			let scene, camera, renderer, stars, starGeo;
			

			function startPage() {

			let buttonClose = document.getElementById('buttonClose').style.display = 'none';
			let buttonOpen = document.getElementById('button').style.display = 'none';

			scene = new THREE.Scene();

			camera = new THREE.PerspectiveCamera(60,window.innerWidth / window.innerHeight, 1, 1000);
			camera.position.z = 1;
			camera.rotation.x = Math.PI/2;

			renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			starGeo = new THREE.Geometry();
			for(let i=0;i<6000;i++) {
				star = new THREE.Vector3(
				Math.random() * 600 - 300,
				Math.random() * 600 - 300,
				Math.random() * 600 - 300
				);
				star.velocity = 0;
				star.acceleration = 0.02;
				starGeo.vertices.push(star);
			}

			let sprite = new THREE.TextureLoader().load( 'textures/star.png' );
			let starMaterial = new THREE.PointsMaterial({
				color: 0xaaaaaa,
				size: 0.7,
				map: sprite
			});

			stars = new THREE.Points(starGeo,starMaterial);
			scene.add(stars);

			window.addEventListener("resize", onWindowResize, false);

			animateStar(); 
			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}
			function animateStar() {
			starGeo.vertices.forEach(p => {
				p.velocity += p.acceleration
				p.y -= p.velocity;
				
				if (p.y < -200) {
				p.y = 200;
				p.velocity = 0;
				}
			});
			starGeo.verticesNeedUpdate = true;
			stars.rotation.y +=0.002;

			renderer.render(scene, camera);
			requestAnimationFrame(animateStar);
			}
			startPage();

		</script>

		<script type="module">

			import * as THREE from '../build/three.module.js';
			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { GUI } from './jsm/libs/dat.gui.module.js';
			import Stats from './jsm/libs/stats.module.js';
			import * as MATERIAL from './material.module.js';
			
			let camera, scene, renderer, controls, stats;
			let groundCorridor, ground, wall1Corridor, wall2Corridor, wallBackCorridor, door1, door2, window1, window2;
			let spotLight, spotLightLeft, spotLightRight, spotLightBack, lightHelper, shadowCameraHelper, gui;
			


			function buildGui() {

			gui = new GUI();

			const params = {
			'Sol': Object.keys(MATERIAL.groundFileList)[0],
			Door1PositionZ: door1.position.z,
			Door2PositionZ: door2.position.z
			};

			gui.open();

			gui.add( params, 'Sol', Object.keys(MATERIAL.groundFileList)).name('Texture sol:').onChange(val => {
				ground.material = MATERIAL.groundFileList[val];
			});

			gui.add( params, 'Door1PositionZ', 320, 920 ).name( 'Door1PositionZ' ).onChange( function ( val ) {

			door1.position.z = val;
			console.log(val);
			render();

			} );


			gui.add( params, 'Door2PositionZ', 320, 920 ).name( 'Door2PositionZ' ).onChange( function ( val ) {

			door2.position.z = -val;
			render();

			} );

			}



			document.getElementById('buttonInit').onclick = function init() {


				let containere, progressBarDiv;

				containere = document.createElement( 'div' );
				document.body.appendChild( containere );

				const container = document.getElementById('container');
                stats = new Stats();
                container.appendChild(stats.dom);

				let buttonClose = document.getElementById('buttonClose').style.display = 'inline-block';
				let buttonOpen = document.getElementById('button').style.display = 'inline-block';
				let textBox = document.getElementById('text-box').style.display = 'none';

				
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( 700, 5000, 10 );
				camera.position.z = 3500;
				camera.position.x = -3500;
				camera.position.y = 3000;

				scene = new THREE.Scene();

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				document.body.appendChild( renderer.domElement );

				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				renderer.outputEncoding = THREE.sRGBEncoding;

				progressBarDiv = document.createElement( 'div' );
				progressBarDiv.innerText = 'Loading...';
				progressBarDiv.style.fontSize = '3em';
				progressBarDiv.style.color = '#888';
				progressBarDiv.style.display = 'block';
				progressBarDiv.style.position = 'absolute';
				progressBarDiv.style.fontFamily = 'Russo One';
				progressBarDiv.style.top = '50%';
				progressBarDiv.style.width = '100%';
				progressBarDiv.style.textAlign = 'center';


				animate();

				spotLightRight = new THREE.SpotLight( 0xffffff, 10 );
				//spotLight.position.set( 200, 700, 100 );
                spotLightRight.position.x = 500;
                spotLightRight.position.y = 2500;
                spotLightRight.position.z = -10000;
				spotLightRight.angle = Math.PI / 4;
				spotLightRight.penumbra = 0.5;
				spotLightRight.intensity = 5;
				spotLightRight.decay = 2;
				spotLightRight.distance = 13000;

				spotLightRight.castShadow = true;
				spotLightRight.shadow.mapSize.width = 1024;
				spotLightRight.shadow.mapSize.height = 1024;
				spotLightRight.shadow.camera.near = 100;
				spotLightRight.shadow.camera.far = 100;
				spotLightRight.shadow.focus = 1;
				scene.add( spotLightRight );

				spotLightLeft = new THREE.SpotLight( 0xffffff, 10 );
				//spotLight.position.set( 200, 700, 100 );
                spotLightLeft.position.x = 500;
                spotLightLeft.position.y = 2500;
                spotLightLeft.position.z = 10000;
				spotLightLeft.angle = Math.PI / 4;
				spotLightLeft.penumbra = 0.5;
				spotLightLeft.intensity = 5;
				spotLightLeft.decay = 2;
				spotLightLeft.distance = 13000;

				spotLightLeft.castShadow = true;
				spotLightLeft.shadow.mapSize.width = 1024;
				spotLightLeft.shadow.mapSize.height = 1024;
				spotLightLeft.shadow.camera.near = 100;
				spotLightLeft.shadow.camera.far = 100;
				spotLightLeft.shadow.focus = 1;
				scene.add( spotLightLeft );

				spotLight = new THREE.SpotLight( 0xffffff, 10 );
				//spotLight.position.set( 200, 700, 100 );
                spotLight.position.x = -6000;
                spotLight.position.y = 5000;
                spotLight.position.z = 0;
				spotLight.angle = Math.PI / 4;
				spotLight.penumbra = 0.5;
				spotLight.intensity = 5;
				spotLight.decay = 2;
				spotLight.distance = 18000;

				spotLight.castShadow = true;
				spotLight.shadow.mapSize.width = 1024;
				spotLight.shadow.mapSize.height = 1024;
				spotLight.shadow.camera.near = 100;
				spotLight.shadow.camera.far = 100;
				spotLight.shadow.focus = 1;
				scene.add( spotLight );

				spotLightBack = new THREE.SpotLight( 0xffffff, 10 );
				//spotLight.position.set( 200, 700, 100 );
                spotLightBack.position.x = 5000;
                spotLightBack.position.y = -10000;
                spotLightBack.position.z = 2000;
				spotLightBack.angle = Math.PI / 4;
				spotLightBack.penumbra = 0.5;
				spotLightBack.intensity = 5;
				spotLightBack.decay = 2;
				spotLightBack.distance = 18000;

				spotLightBack.castShadow = true;
				spotLightBack.shadow.mapSize.width = 1024;
				spotLightBack.shadow.mapSize.height = 1024;
				spotLightBack.shadow.camera.near = 100;
				spotLightBack.shadow.camera.far = 100;
				spotLightBack.shadow.focus = 1;
				scene.add( spotLightBack );

				lightHelper = new THREE.SpotLightHelper( spotLight, spotLightRight, spotLightLeft );
				scene.add(lightHelper);

				shadowCameraHelper = new THREE.CameraHelper( spotLight.shadow.camera, spotLightLeft.shadow.camera, spotLightRight.shadow.camera );
				scene.add(shadowCameraHelper);
				

				// Textures navette

				const groundCorridortexture = new THREE.TextureLoader().load( './textures/texture-sol-navette.jpg' );
				const wallCorridortexture = new THREE.TextureLoader().load( './textures/texture-mur-navette.jpg' );
				const doorTexture = new THREE.TextureLoader().load( './textures/porte-spatiale.jpg' );

				// Ground texture

				const groundMarstexture = new THREE.TextureLoader().load( './textures/sol-texture-mars.jpg' );
				const groundMoontexture = new THREE.TextureLoader().load('./textures/texture-moon.jpg');
				const groundNeptunetexture = new THREE.TextureLoader().load('./textures/texture-neptune.jpg');
				const groundSuntexture = new THREE.TextureLoader().load('./textures/texture-sun.png');

				// Ground materiaux

				const groundMoonmaterial = new THREE.MeshPhongMaterial( { map:groundMoontexture } );
				const groundNeptunematerial = new THREE.MeshPhongMaterial( { map:groundNeptunetexture } );
				const groundSunmaterial = new THREE.MeshPhongMaterial( { map:groundSuntexture } );

				/* Couloir */

				const groundCorridormaterial = new THREE.MeshPhongMaterial( { map:groundCorridortexture } );
				const groundCorridorgeometry = new THREE.BoxGeometry( 3500, 1200, 50 );
				
				groundCorridor = new THREE.Mesh( groundCorridorgeometry, groundCorridormaterial );
				groundCorridor.rotation.x = Math.PI * 0.5;
				groundCorridor.receiveShadow = true;
				groundCorridor.position.y = 50;
				scene.add( groundCorridor );

				
				const groundGeometry = new THREE.BoxGeometry( 10000, 10000, 50 );
				ground = new THREE.Mesh( groundGeometry, MATERIAL.groundFileList.Mars );
				ground.rotation.x = Math.PI * 0.5;
				ground.receiveShadow = true;
				scene.add( ground );


				const wall1Corridormaterial = new THREE.MeshPhongMaterial( { map:wallCorridortexture } );
				const wall1Corridorgeometry = new THREE.BoxGeometry(3500, 1500, 50);

				wall1Corridor = new THREE.Mesh( wall1Corridorgeometry, wall1Corridormaterial );
				wall1Corridor.position.y = 775;
				wall1Corridor.position.z = 625;
				wall1Corridor.castShadow = true;
				wall1Corridor.receiveShadow = true;
				scene.add(wall1Corridor);

				const wall2Corridormaterial = new THREE.MeshPhongMaterial( { map:wallCorridortexture } );
				const wall2Corridorgeometry = new THREE.BoxGeometry(3500, 1500, 50);

				wall2Corridor = new THREE.Mesh( wall2Corridorgeometry, wall2Corridormaterial );
				wall2Corridor.position.y = 775;
				wall2Corridor.position.z = -625;
				wall2Corridor.castShadow = true;
				wall2Corridor.receiveShadow = true;
				scene.add(wall2Corridor);

				const wallBackCorridormaterial = new THREE.MeshPhongMaterial( { map:wallCorridortexture } );
				const wallBackCorridorgeometry = new THREE.BoxGeometry(1300, 1500, 50);

				wallBackCorridor = new THREE.Mesh( wallBackCorridorgeometry, wallBackCorridormaterial );
				wallBackCorridor.position.y = 775;
				wallBackCorridor.position.z = 0; 
				wallBackCorridor.position.x = 1770;
				wallBackCorridor.rotation.y = Math.PI * 0.5;
				wallBackCorridor.castShadow = true;
				wallBackCorridor.receiveShadow = true;
				scene.add(wallBackCorridor);

				const door1material = new THREE.MeshPhongMaterial( { map:doorTexture } );
				const door1geometry = new THREE.BoxGeometry(650, 1500,20); 

				door1 = new THREE.Mesh( door1geometry, door1material );
				door1.position.y = 775;
				door1.position.z = 320; 
				door1.position.x = -1760;
				door1.rotation.y = Math.PI * 0.5;
				door1.castShadow = true;
				door1.receiveShadow = true;
				scene.add(door1);

				const door2material = new THREE.MeshPhongMaterial( { map:doorTexture } );
				const door2geometry = new THREE.BoxGeometry(650, 1500,20); 

				door2 = new THREE.Mesh( door2geometry, door2material );
				door2.position.y = 775;
				door2.position.z = -320; 
				door2.position.x = -1760;
				door2.rotation.y = Math.PI * 0.5;
				door2.castShadow = true;
				door2.receiveShadow = true;
				scene.add(door2);


			
				/* Fin Couloir */

				// create an AudioListener and add it to the camera
				const listener = new THREE.AudioListener();
				camera.add( listener );

				// create a global audio source
				const sound = new THREE.Audio( listener );

				// load a sound and set it as the Audio object's buffer
				const audioLoader = new THREE.AudioLoader();
				

			
				
				document.getElementById('button').onclick = function openDoor() {
					
					showProgressBar();
					updateProgressBar( 0 );

					let door1positionZ = door1.position.z;
					let door2positionZ = door2.position.z;
					console.log("Door1: " + door1positionZ +" "+" "+ "Door2: " + door2positionZ);

					if (door1positionZ == 920 && door2positionZ == -920){
						alert("Les portes sont déjà ouverte!");
						hideProgressBar();
					} else {
						while(door1positionZ < 920 && door2positionZ > -920) {
						
						if (door1positionZ == 320 && door2positionZ == -320) {
							audioLoader.load( 'sounds/ouverture-porte.mp3', function( buffer ) {
							sound.setBuffer( buffer );
							sound.setLoop( false );
							sound.setVolume( 5 );
							sound.play();
						});
						}

						// Vitesse de l'animation
						door1positionZ += 100;
						door2positionZ += -100;
						console.log(door1positionZ);
						console.log(door2positionZ);

						// Fin d'animation
						if(door1positionZ == 920 && door2positionZ == -920) {
							console.log("Position final door1: " + door1positionZ,
							"Position final door2: " + door2positionZ);
							if (document.getElementById('buttonClose').style.color = 'red') {
								document.getElementById('button').style.color = 'black';
							} else {
							document.getElementById('button').style.color = 'green';
							}
							alert('Porte ouverte!');
							
						}
						
						
						door1.position.z = door1positionZ;
						door2.position.z = door2positionZ;
						render();
						
					}
					hideProgressBar();
					
				}

				}

				document.getElementById('buttonClose').onclick = function closeDoor() {

					showProgressBar();
					updateProgressBar( 0 );

					let door1positionZ = door1.position.z;
					let door2positionZ = door2.position.z;
					console.log("Door1: " + door1positionZ +" "+" "+ "Door2: " + door2positionZ);
					

					if (door1positionZ == 320 && door2positionZ == -320){
						alert("Les portes sont déjà fermées!");
						hideProgressBar();
					} else {
						while(door1positionZ > 320 && door2positionZ < -320) {
							
							// Vitesse de l'animation
							door1positionZ += -100;
							door2positionZ += 100;
							console.log(door1positionZ);
							console.log(door2positionZ);

							// Fin d'animation
							if(door1positionZ == 320 && door2positionZ == -320) {
								console.log("Position final door1: " + door1positionZ,
								"Position final door2: " + door2positionZ);
								if (document.getElementById('button').style.color = 'green') {
									document.getElementById('buttonClose').style.color = 'black';
								} else {
								document.getElementById('buttonClose').style.color = 'red';
								}
								alert('Porte fermée!');
								

						}
						
						door1.position.z = door1positionZ;
						door2.position.z = door2positionZ;
						render();
						
						}
						hideProgressBar();
					}
					

					

					

				}

				// Orbit controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', render );
				controls.minDistance = 20;
				controls.maxDistance = 5000;
				controls.enablePan = false;


				window.addEventListener( 'resize', onWindowResize );

				buildGui();

				function onProgress( xhr ) {

				if ( xhr.lengthComputable ) {

					updateProgressBar( xhr.loaded / xhr.total );

					console.log( Math.round( xhr.loaded / xhr.total * 100, 2 ) + '% downloaded' );

				}

				}

				function showProgressBar() {

				document.body.appendChild( progressBarDiv );

				}

				function hideProgressBar() {

				document.body.removeChild( progressBarDiv );

				}

				function updateProgressBar( fraction ) {

				progressBarDiv.innerText = 'Loading... ' + Math.round( fraction * 100, 2 ) + '%';

				}

			}

			

			function animate() {

			requestAnimationFrame( animate );

			//controls.update();

			renderer.render( scene, camera );

			stats.update();

			}


			function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

			}


		
			function render() {


			lightHelper.update();

			shadowCameraHelper.update();

			renderer.render( scene, camera );

			}



	</script>

    </body>
</html>