<!DOCTYPE html>
<html lang="fr">
	<head>
		<title>Couloir Projet WebGL</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="stylesheet" href="css/style.css">
		<link rel="shortcut icon" type="image/png" href="./textures/favicon.jpg">
		
	</head>
	<body>

		<audio id="scifiTable" loop preload="auto" style="display: none">
            <source src="./sounds/scifiTable.mp3" type="audio/mpeg">
        </audio>

		<div id="container"></div>
		<div id="loader"></div>
		
	
		<script type="module">

			import * as THREE from '../build/three.module.js';
			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { GUI } from './jsm/libs/dat.gui.module.js';
			import Stats from './jsm/libs/stats.module.js';
			import * as MATERIAL from './material.module.js';
			import { FBXLoader } from './jsm/loaders/FBXLoader.js';
			//import { FirstPersonControls } from './jsm/controls/FirstPersonControls.js';
			import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
			
			let camera, scene, renderer, controls, stats, planeteJupiter;
			let groundCorridor, ground;
			let spotLight, spotLightLeft, spotLightRight, spotLightBack, lightHelper, shadowCameraHelper, gui, AxeHelper;
			let corridorStarWars;
			let moonGround = false;

			let showAxeHelper = false;
			let showCameraHelper = false;
			let showLightHelper = false;
			var loader = new GLTFLoader();
			let analyser, data, songElement;


			const clock = new THREE.Clock();

			let mixer;
			

			function buildGui() {

			gui = new GUI();

			const params = {
			'Sol': Object.keys(MATERIAL.groundFileList)[0],
			AxeHelper: showAxeHelper,
			LightHelper: showLightHelper,
			ShadowHelper: showCameraHelper
			};

			gui.open();

			gui.add( params, 'Sol', Object.keys(MATERIAL.groundFileList)).name('Texture sol:').onChange(val => {
				
				ground.material = MATERIAL.groundFileList[val];
				console.log(val);
			});

			gui.add( params, 'AxeHelper' ).name( 'Axe Helpers' ).onChange(() => {
            if(!showAxeHelper){
                scene.add(AxeHelper);
            } else {
                scene.remove(AxeHelper);
            }
            showAxeHelper = !showAxeHelper;

            } );

			gui.add( params, 'LightHelper' ).name( 'Light Helpers' ).onChange(() => {
                if(!showLightHelper){
                    scene.add(lightHelper);
                } else {
                    scene.remove(lightHelper);
                }
                showLightHelper = !showLightHelper;

            } );

			gui.add( params, 'ShadowHelper' ).name( 'Shadow Helpers' ).onChange(() => {
                if(!showCameraHelper){
                    scene.add(shadowCameraHelper);
                } else {
                    scene.remove(shadowCameraHelper);
                }
                showCameraHelper = !showCameraHelper;

            } );

			}

				init();
				animate();

				function init() {


				let containere;

				containere = document.createElement( 'div' );
				document.body.appendChild( containere );

				const container = document.getElementById('container');
                stats = new Stats();
                container.appendChild(stats.dom);

				
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 100000 );
				camera.position.set( 700, 5000, 5000 );
				camera.position.z = 5000;
				camera.position.x = -8000;
				camera.position.y = 3000;

				scene = new THREE.Scene();

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				document.body.appendChild( renderer.domElement );

				renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				renderer.outputEncoding = THREE.sRGBEncoding;
				

				const light = new THREE.AmbientLight( 0x404040 ); // soft white light
				light.intensity = 0.7;
				scene.add( light );


				spotLightRight = new THREE.SpotLight( 0xffffff, 10 );
				//spotLight.position.set( 200, 700, 100 );
                spotLightRight.position.x = 500;
                spotLightRight.position.y = 2500;
                spotLightRight.position.z = -10000;
				spotLightRight.angle = Math.PI / 4;
				spotLightRight.penumbra = 0.5;
				spotLightRight.intensity = 5;
				spotLightRight.decay = 2;
				spotLightRight.distance = 13000;

				spotLightRight.castShadow = true;
				spotLightRight.shadow.mapSize.width = 1024;
				spotLightRight.shadow.mapSize.height = 1024;
				spotLightRight.shadow.camera.near = 100;
				spotLightRight.shadow.camera.far = 100;
				spotLightRight.shadow.focus = 1;
				scene.add( spotLightRight );

				spotLightLeft = new THREE.SpotLight( 0xffffff, 10 );
				//spotLight.position.set( 200, 700, 100 );
                spotLightLeft.position.x = 500;
                spotLightLeft.position.y = 2500;
                spotLightLeft.position.z = 10000;
				spotLightLeft.angle = Math.PI / 4;
				spotLightLeft.penumbra = 0.5;
				spotLightLeft.intensity = 5;
				spotLightLeft.decay = 2;
				spotLightLeft.distance = 13000;

				spotLightLeft.castShadow = true;
				spotLightLeft.shadow.mapSize.width = 1024;
				spotLightLeft.shadow.mapSize.height = 1024;
				spotLightLeft.shadow.camera.near = 100;
				spotLightLeft.shadow.camera.far = 100;
				spotLightLeft.shadow.focus = 1;
				scene.add( spotLightLeft );

				spotLight = new THREE.SpotLight( 0xffffff, 10 );
				//spotLight.position.set( 200, 700, 100 );
                spotLight.position.x = -6000;
                spotLight.position.y = 5000;
                spotLight.position.z = 0;
				spotLight.angle = Math.PI / 4;
				spotLight.penumbra = 0.5;
				spotLight.intensity = 5;
				spotLight.decay = 2;
				spotLight.distance = 18000;

				spotLight.castShadow = true;
				spotLight.shadow.mapSize.width = 1024;
				spotLight.shadow.mapSize.height = 1024;
				spotLight.shadow.camera.near = 100;
				spotLight.shadow.camera.far = 100;
				spotLight.shadow.focus = 1;
				scene.add( spotLight );

				spotLightBack = new THREE.SpotLight( 0xffffff, 10 );
				//spotLight.position.set( 200, 700, 100 );
                spotLightBack.position.x = 5000;
                spotLightBack.position.y = -10000;
                spotLightBack.position.z = 2000;
				spotLightBack.angle = Math.PI / 4;
				spotLightBack.penumbra = 0.5;
				spotLightBack.intensity = 5;
				spotLightBack.decay = 2;
				spotLightBack.distance = 18000;

				spotLightBack.castShadow = true;
				spotLightBack.shadow.mapSize.width = 1024;
				spotLightBack.shadow.mapSize.height = 1024;
				spotLightBack.shadow.camera.near = 100;
				spotLightBack.shadow.camera.far = 100;
				spotLightBack.shadow.focus = 1;
				scene.add( spotLightBack );

				lightHelper = new THREE.SpotLightHelper( spotLight, spotLightRight, spotLightLeft );
				if (showLightHelper) scene.add(lightHelper);

				shadowCameraHelper = new THREE.CameraHelper( spotLight.shadow.camera, spotLightLeft.shadow.camera, spotLightRight.shadow.camera );
				if (showCameraHelper) scene.add(shadowCameraHelper);

				AxeHelper = new THREE.AxesHelper( 10000 );
				if(showAxeHelper) scene.add(AxeHelper);

				const corridor_loader = new GLTFLoader().setPath( './structure/' );
						corridor_loader.load( 'corridor.glb', function ( gltf ) {

							let corridor = gltf.scene
							corridor.scale.x = 200;
							corridor.scale.y = 200;
							corridor.scale.z = 200;
							corridor.position.x = 7000;
							corridor.position.y = 27;
							corridor.receiveShadow = true;
							corridor.castShadow = true;


							scene.add( corridor );
							// hide spinner
							document.getElementById( 'loader' ).style.display = 'none';


							render();
						

						}, function (xhr) {
								console.log((xhr.loaded/xhr.total * 100) + "% loaded corridor");
							}, function (error) {
								console.log("An error occurred");
							});

						const jupiter_loader = new GLTFLoader().setPath( './structure/' );
						jupiter_loader.load( 'planete-jupiter.glb', function ( gltf ) {

							let jupiter = gltf.scene
							jupiter.scale.x = 3000;
							jupiter.scale.y = 3000;
							jupiter.scale.z = 3000;
							jupiter.position.x = 10000;
							jupiter.position.z = 50000;
							jupiter.position.y = 1000;
							jupiter.receiveShadow = true;
							jupiter.castShadow = true;
							


							scene.add( jupiter );
							// hide spinner
							document.getElementById( 'loader' ).style.display = 'none';


							render();
							

						}, function (xhr) {
								console.log((xhr.loaded/xhr.total * 100) + "% loaded jupiter");
							}, function (error) {
								console.log("An error occurred");
							});

							
						const loader = new GLTFLoader().setPath( './structure/' );
						loader.load( 'planete-moon.glb', function ( gltf ) {

							//console.log(gltf);
							let moon = gltf.scene
							moon.scale.x = 1000;
							moon.scale.y = 1000;
							moon.scale.z = 1000;
							moon.position.x = 10000;
							moon.position.z = -50000;
							moon.position.y = 1000;
							moon.receiveShadow = true;
							moon.castShadow = true;
							
							scene.add(moon);
							
							// hide spinner
							document.getElementById( 'loader' ).style.display = 'none';

							render();
							

							}, function (xhr) {
								console.log((xhr.loaded/xhr.total * 100) + "% loaded moon");
							
							}, function (error) {
								console.log("An error occurred");
							});

						
						loader.load( 'box-Space.glb', function ( gltf ) {

							let boxes = gltf.scene
							boxes.scale.x = 100;
							boxes.scale.y = 100;
							boxes.scale.z = 100;
							boxes.position.x = -1200;
							boxes.position.z = 300;
							boxes.position.y = -100;
							boxes.positionreceiveShadow = true;
							boxes.castShadow = true;
							
							scene.add(boxes);
							// hide spinner
							document.getElementById( 'loader' ).style.display = 'none';

							render();
							

						}, function (xhr) {
								console.log((xhr.loaded/xhr.total * 100) + "% loaded boxes");
							}, function (error) {
								console.log("An error occurred");
							});
						
						loader.load( 'box-Space.glb', function ( gltf ) {

							let boxes2 = gltf.scene
							boxes2.scale.x = 100;
							boxes2.scale.y = 100;
							boxes2.scale.z = 100;
							boxes2.position.x = 1200;
							boxes2.position.z = 300;
							boxes2.position.y = -100;
							boxes2.positionreceiveShadow = true;
							boxes2.castShadow = true;
							
							scene.add(boxes2);
							// hide spinner
							document.getElementById( 'loader' ).style.display = 'none';

							render();
							

						}, function (xhr) {
								console.log((xhr.loaded/xhr.total * 100) + "% loaded boxes");
							}, function (error) {
								console.log("An error occurred");
							});
						
						loader.load( 'box-Space.glb', function ( gltf ) {

							let boxes3 = gltf.scene
							boxes3.scale.x = 100;
							boxes3.scale.y = 100;
							boxes3.scale.z = 100;
							boxes3.position.x = 2200;
							boxes3.position.z = -600;
							boxes3.position.y = -100;
							boxes3.positionreceiveShadow = true;
							boxes3.castShadow = true;
							
							scene.add(boxes3);
							// hide spinner
							document.getElementById( 'loader' ).style.display = 'none';


							render();
							
						}, function (xhr) {
								console.log((xhr.loaded/xhr.total * 100) + "% loaded boxes");
							}, function (error) {
								console.log("An error occurred");
							});
						
						loader.load( 'box-Space.glb', function ( gltf ) {

							let boxes4 = gltf.scene
							boxes4.scale.x = 100;
							boxes4.scale.y = 100;
							boxes4.scale.z = 100;
							boxes4.position.x = 4000;
							boxes4.position.z = -600;
							boxes4.position.y = -100;
							boxes4.positionreceiveShadow = true;
							boxes4.castShadow = true;
							
							scene.add(boxes4);
							// hide spinner
							document.getElementById( 'loader' ).style.display = 'none';

							render();
							

						}, function (xhr) {
								console.log((xhr.loaded/xhr.total * 100) + "% loaded boxes");
							}, function (error) {
								console.log("An error occurred");
							});

						let scientificTable;

						loader.load( 'sci-fi-table.glb', function ( gltf ) {

							scientificTable = gltf.scene
							scientificTable.scale.x = 1700;
							scientificTable.scale.y = 1700;
							scientificTable.scale.z = 1700;
							scientificTable.position.x = -4700;
							scientificTable.position.z = 0;
							scientificTable.position.y = 200;
							scientificTable.rotation.y = Math.PI * 1.5;

							scene.add(scientificTable);
							// hide spinner
							document.getElementById( 'loader' ).style.display = 'none';


							render();
							

							}, function (xhr) {
								console.log((xhr.loaded/xhr.total * 100) + "% loaded sciTable");
							}, function (error) {
								console.log("An error occurred");
							});

				// create an AudioListener and add it to the camera
				const listener = new THREE.AudioListener();
				camera.add( listener );

				// create a global audio source
				const sound = new THREE.Audio( listener );

				// load a sound and set it as the Audio object's buffer
				const audioLoader = new THREE.AudioLoader();
				audioLoader.load( './sounds/starwars-cantina.mp3', function( buffer ) {
					sound.setBuffer( buffer );
					sound.setLoop( true );
					sound.setVolume( 0.10 );
					sound.play();
				});

				// create the PositionalAudio object (passing in the listener)

				let soundScifi = new THREE.Audio( listener );
				soundScifi = new THREE.PositionalAudio( listener );
                const oscillator = listener.context.createOscillator();
                oscillator.type = 'sine';
				oscillator.frequency.setValueAtTime( 144, soundScifi.context.currentTime );
				oscillator.start( 0 );
                songElement = document.getElementById( 'scifiTable' );
                soundScifi.setMediaElementSource( songElement );
                soundScifi.setRefDistance( 400 );
                songElement.play();


                //analyser of sound
                analyser = new THREE.AudioAnalyser(sound, 32);
                data = analyser.getAverageFrequency();


				const groundGeometry = new THREE.BoxGeometry( 18000, 18000, 50 );
				ground = new THREE.Mesh( groundGeometry, MATERIAL.groundFileList.Mars );
				ground.rotation.x = Math.PI * 0.5;
				ground.receiveShadow = true;
				scene.add( ground );

				// Textures pièce space

				const groundRoomTexture = new THREE.TextureLoader().load('./textures/texture-sol.jpg');
				const stairsTexture = new THREE.TextureLoader().load('./textures/texture-sol-stairs.jpg');
				const wallTexture = new THREE.TextureLoader().load( './textures/texture-mur-navette.jpg' );


				// Sol pièce
				const groundRoomMaterial = new THREE.MeshPhongMaterial( { map:groundRoomTexture } );
				const groundRoomGeometry = new THREE.BoxGeometry(5000, 5000, 50);
				const groundRoom = new THREE.Mesh( groundRoomGeometry, groundRoomMaterial);
				groundRoom.position.x = -4560;
				groundRoom.position.y = 50;
				groundRoom.position.z = 0;
				groundRoom.rotation.x = Math.PI * 1.5;
				groundRoom.receiveShadow = true;
				scene.add( groundRoom );

				const stairs1Material = new THREE.MeshPhongMaterial( { map:stairsTexture } );
				const stairs1Geometry = new THREE.BoxGeometry(2500, 2500, 50);
				const stairs1 = new THREE.Mesh( stairs1Geometry, stairs1Material);
				stairs1.position.x = -4700;
				stairs1.position.y = 100;
				stairs1.position.z = 0;
				stairs1.rotation.x = Math.PI * 1.5;
				stairs1.receiveShadow = true;
				scene.add( stairs1 );

				const stairs2Material = new THREE.MeshPhongMaterial( { map:stairsTexture } );
				const stairs2Geometry = new THREE.BoxGeometry(2000, 2000, 50);
				const stairs2 = new THREE.Mesh( stairs2Geometry, stairs2Material);
				stairs2.position.x = -4700;
				stairs2.position.y = 150;
				stairs2.position.z = 0;
				stairs2.rotation.x = Math.PI * 1.5;
				stairs2.receiveShadow = true;
				scene.add( stairs2 );

				const stairs3Material = new THREE.MeshPhongMaterial( { map:stairsTexture } );
				const stairs3Geometry = new THREE.BoxGeometry(1500, 1500, 50);
				const stairs3 = new THREE.Mesh( stairs3Geometry, stairs3Material);
				stairs3.position.x = -4700;
				stairs3.position.y = 200;
				stairs3.position.z = 0;
				stairs3.rotation.x = Math.PI * 1.5;
				stairs3.receiveShadow = true;
				scene.add( stairs3 );
				stairs3.add(soundScifi);
			


				// Murs pièce

				const wall1Material = new THREE.MeshPhongMaterial( { map:wallTexture } );
				const wall1Geometry = new THREE.BoxGeometry(5000, 1800, 100);
				const wall1 = new THREE.Mesh(wall1Geometry, wall1Material );
				wall1.position.x = -4550;
				wall1.position.y = 920;
				wall1.position.z = -2550;
				wall1.receiveShadow = true;
				wall1.castShadow = true;
				scene.add( wall1 );

				const wall2Material = new THREE.MeshPhongMaterial( { map:wallTexture } );
				const wall2Geometry = new THREE.BoxGeometry(5000, 1800, 100);
				const wall2 = new THREE.Mesh(wall2Geometry, wall2Material );
				wall2.position.x = -4550;
				wall2.position.y = 920;
				wall2.position.z = 2550;
				wall2.receiveShadow = true;
				wall2.castShadow = true;
				scene.add( wall2 );

				const wall3Material = new THREE.MeshPhongMaterial( { map:wallTexture } );
				const wall3Geometry = new THREE.BoxGeometry(5000, 1800, 100);
				const wall3 = new THREE.Mesh(wall3Geometry, wall3Material );
				wall3.position.x = -7100;
				wall3.position.y = 920;
				wall3.position.z = 0;
				wall3.rotation.y = Math.PI * 1.5;
				wall3.receiveShadow = true;
				wall3.castShadow = true;
				scene.add( wall3 );

				const wall4Material = new THREE.MeshPhongMaterial( { map:wallTexture } );
				const wall4Geometry = new THREE.BoxGeometry(1850, 1800, 100);
				const wall4 = new THREE.Mesh(wall4Geometry, wall4Material );
				wall4.position.x = -2000;
				wall4.position.y = 920;
				wall4.position.z = 1650;
				wall4.rotation.y = Math.PI * 1.5;
				wall4.receiveShadow = true;
				wall4.castShadow = true;
				scene.add( wall4 );

				const wall5Material = new THREE.MeshPhongMaterial( { map:wallTexture } );
				const wall5Geometry = new THREE.BoxGeometry(1850, 1800, 100);
				const wall5 = new THREE.Mesh(wall5Geometry, wall5Material );
				wall5.position.x = -2000;
				wall5.position.y = 920;
				wall5.position.z = -1650;
				wall5.rotation.y = Math.PI * 1.5;
				wall5.receiveShadow = true;
				wall5.castShadow = true;
				scene.add( wall5 );

				

				// Orbit controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', render );
				controls.minDistance = 20;
				controls.maxDistance = 10000;
				controls.enablePan = false;

				/*controls = new FirstPersonControls( camera, renderer.domElement );

				controls.movementSpeed = 10000;
				controls.lookSpeed = 10;
				controls.noFly = true;
				controls.lookVertical = true;
                controls.lookHorizontal = true;

                controls.keys = {
	                LEFT: 81, //left arrow
	                UP: 90, // up arrow
	                RIGHT: 68, // right arrow
	                BOTTOM: 83 // down arrow
                }*/


				window.addEventListener( 'resize', onWindowResize );

				buildGui();
			}

				

			function animate() {


			requestAnimationFrame( animate );

			//controls.update();

			renderer.render( scene, camera );


			//scene.rotation.y += 0.001;


			stats.update();


			}


			function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );

			//controls.handleResize();

			}


		
			function render() {


			lightHelper.update();

			shadowCameraHelper.update();

			renderer.render( scene, camera );

			//scientificTable = analyser.getAverageFrequency()/256;

			//controls.update( clock.getDelta() );

			}



	</script>

    </body>
</html>